// SPDX-FileCopyrightText: Steven Ward
// SPDX-License-Identifier: OSL-3.0

/// AES Random Pool (ARP)
/**
\file
\author Steven Ward
Inspired by \c arc4random.
\sa https://github.com/openbsd/src/blob/master/lib/libc/crypt/arc4random.c
\sa https://man7.org/linux/man-pages/man3/arc4random.3.html
*/

#include "../arp.h"

#include "aes128_prng.h"
#include "allocate.h"
#include "nearlydivisionless.h"

#include <immintrin.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>
#include <sys/user.h>

#ifdef __cplusplus
extern "C" {
#endif

#define MIN(a, b) ((a) < (b) ? (a) : (b))

/// How many blocks are in the pool of random data
/**
* The size of each block is \c sizeof(__m128i) (i.e. \c 16).
*/
#if !defined(ARP_NUM_BLOCKS)
#define ARP_NUM_BLOCKS 16
#endif

static_assert(ARP_NUM_BLOCKS >= 1, "arp must have at least 1 block");

#define ARP_NUM_BYTES (ARP_NUM_BLOCKS * sizeof(__m128i))

/// How many times the pool is regenerated before the PRNG is reseeded
/**
* This value is also used as the modulus to calculate a jitter.
*/
#if !defined(ARP_RESEED_COUNTDOWN_MIN)
#define ARP_RESEED_COUNTDOWN_MIN 2048
#endif

static_assert(
    __builtin_popcount(ARP_RESEED_COUNTDOWN_MIN) == 1,
    "arp reseed countdown must be a power of 2 to prevent modulo bias");

/// A pool of random data generated by AES instructions
struct arp
{
	aes128_prng prng;
	size_t reseed_countdown;     // The PRNG is reseeded when this is 0.
	size_t rand_bytes_remaining; // The pool is regenerated when this is 0.
	uint8_t pool[ARP_NUM_BYTES];
};

typedef struct arp arp;

static_assert(sizeof(arp) <= PAGE_SIZE, "arp must fit in one page");

static thread_local arp* this_ = nullptr;

static void
arp_regen()
{
	if (this_->reseed_countdown == 0)
	{
		aes128_prng_reseed(&this_->prng);
		const size_t jitter =
		    (__builtin_ia32_rdtsc() % ARP_RESEED_COUNTDOWN_MIN) / 2;
		this_->reseed_countdown = ARP_RESEED_COUNTDOWN_MIN + jitter;
	}

	__m128i* blocks = (__m128i*)(&this_->pool[0]);

	for (size_t i = 0; i < ARP_NUM_BLOCKS; ++i)
	{
		blocks[i] = aes128_prng_enc_next(&this_->prng);
	}

	this_->rand_bytes_remaining = ARP_NUM_BYTES;
	--this_->reseed_countdown;
}

void
arp_copy_to(void* buf, size_t n)
{
	if (this_ == nullptr)
#ifdef __cplusplus
		this_ = (decltype(this_))allocate(sizeof(*this_));
#else
		this_ = (typeof(this_))allocate(sizeof(*this_));
#endif

	uint8_t* dst = (uint8_t*)buf;

	while (n > 0)
	{
		if (this_->rand_bytes_remaining == 0)
			arp_regen();

		uint8_t* src =
		    &this_->pool[ARP_NUM_BYTES - this_->rand_bytes_remaining];

		const size_t m = MIN(n, this_->rand_bytes_remaining);

		(void)memcpy(dst, src, m);
		// https://en.cppreference.com/w/c/string/byte/memset
#if defined(memset_explicit)
		// https://open-std.org/jtc1/sc22/wg14/www/docs/n2897.htm
		(void)memset_explicit(src, 0, m);
#else
		(void)memset(src, 0, m);
#endif

		dst += m;
		this_->rand_bytes_remaining -= m;
		n -= m;
	}
}

void
arp_reseed()
{
	if (this_ == nullptr)
#ifdef __cplusplus
		this_ = (decltype(this_))allocate(sizeof(*this_));
#else
		this_ = (typeof(this_))allocate(sizeof(*this_));
#endif
	else
		this_->reseed_countdown = 0;

	arp_regen();
}

uint8_t
arp_u8()
{
	uint8_t result = 0;
	arp_copy_to(&result, sizeof(result));
	return result;
}

uint16_t
arp_u16()
{
	uint16_t result = 0;
	arp_copy_to(&result, sizeof(result));
	return result;
}

uint32_t
arp_u32()
{
	uint32_t result = 0;
	arp_copy_to(&result, sizeof(result));
	return result;
}

uint64_t
arp_u64()
{
	uint64_t result = 0;
	arp_copy_to(&result, sizeof(result));
	return result;
}

uint32_t
arp_lt_u32(uint32_t upper_bound)
{
	if (upper_bound == 0)
		return arp_u32();
	return random_bounded_nearlydivisionless32(upper_bound, arp_u32);
}

#ifdef __cplusplus
}
#endif
